Agile Methodologies

Agile software life cycles comprise of short iterations, with working software released at the end of each iteration. Learn the principles of agile development and some of the main agile methodologies.

Table of Contents
Agile Software Development and the Agile Manifesto
The Twelve Principles of the Agile Manifesto
The Whole Team Approach
Early and Frequent Feedback
Extreme Programming (XP)
Scrum
Kanban
Collaborative User Stories
Creation of User Stories
Retrospectives
Continuous Integration
Release and Iteration Planning
Agile Software Development and the Agile Manifesto 
Welcome to Agile Software Development and the Agile Manifesto. In this video, we'll be talking about the history of the Agile Manifesto and we'll also dive into the main values of the manifesto. The Agile Manifesto was written in February of 2001 by a group of 17 software practitioners of several programming methodologies. This group went on to create what is now known as the Agile Alliance. These practitioners had come together to evaluate the ways in which companies and teams doing software development were working together and to discuss better ways of working together. As a result of coming together, these practitioners came up with and agreed on four main values and 12 principles that embody the spirit of what any Agile framework or methodology is based on. The Agile Manifesto with its main values forms an umbrella over a number of different Agile methods and frameworks; meaning, that the specifics of implementing some frameworks maybe different, but they all share the main values and principles. 

The first value that is in the Agile Manifesto states that we value individuals and interactions over processes and tools. One thing to note as we go through each of these values is that the practitioners that wrote the values claimed that we value the items on the right, but we value the items on the left more. So when we say individuals and interactions over processes and tools, that does not mean that we don't value processes and tools, but it means that we value individuals and interactions more than processes and tools. Also what that means is that we want to start with people. Once we figure out people, and the people dynamics, and the interactions that are appropriate, then we can figure out the right processes and tools and those follow after we figured out the first part. We also want to allow individuals to contribute to the development of a project whether that's in terms of the requirements or improving the way that we do things, improving the way that we work together. Individuals have great ideas and following processes rigidly does not allow for the contribution of those ideas and of those improved processes. Another point is with human interaction, we want to readily be able to adapt to new ideas and innovations. So we want to create the human interactions in our teams that allow for those that adaptation and that allow for our evolution of new ideas and innovations to fulfill the requirements that we've received. 

The second value in the Agile Manifesto states that we value working software over comprehensive documentation. Many teams spend a lot of time doing comprehensive documentation and writing pages and pages of requirements and spec talks, whereas within Agile methods, we value more reaching to a point where we have working software. What we mean by working software is that it's been developed, tested, integrated, and documented. So as we've noted before, documentation is still important, but we want to achieve the level of documentation that's just enough versus going overboard. Some of the documentation that you may see in an Agile project will be requirements documentation usually in the form of user stories and acceptance criteria and some of the product technical specifications. Sometimes, many developers in an Agile framework will document their code within the code itself. The third value of the Agile Manifesto states that we value customer collaboration over contract negotiation. What that means is that we really value collaboration over confrontation, over changes and requirements, or adding new things to our original requirements. We want to feel that we're collaborating with our customers versus negotiating with them. By collaborating, we're producing better products and we're fulfilling their needs. 

The key points when it comes to a customer collaboration that we want to think about are the project start. So when do we start the project, the scope, and the time that we expect to spend on the project, and when is the project suppose to end. Those are usually the main points of collaboration that we want to start looking at in terms of a collaborative mindset versus negotiating. The fourth and last value of the Agile Manifesto states that we value responding to change over following a plan. We have to realize that change can be of value and can bring added value to our projects. We want to be able to respond quickly to that change in order to fulfill our customer's desires and needs also our product users, so the users of the product maybe different than the customers who are paying for the products and then also in order to stay ahead of the market. 
The Twelve Principles of the Agile Manifesto 
In this video, we'll be presenting the twelve principles of the Agile Manifesto. And we'll be talking about them in the order of who is the most impacted by those principles. There are number of principles in the Agile Manifesto that impacts the customer and that are customer focused. For example, early and continuous delivery of software, the authors of the Agile Manifesto stated that their highest priority was to satisfy the customer through early and continuous delivery of valuable software, again talking about the importance of delivering value. Second is welcoming changing requirements. Again, the authors of the manifesto wanted to make sure that teams understood that it's important to welcome changing requirements evenly in the development phase. Agile processes harness change for the customer's competitive advantage. And the only way to do so in many cases is to be flexible when it comes to requirements. And third deliver working software frequently, some of the iteration links can be anywhere between one week and four weeks, but as we have mentioned in other videos, the preference is to keep the iteration length short. 

The Agile Manifesto also has a number of team-focused principles, for example, business and developers work together daily. The Agile Manifesto emphasizes the importance of the business and the development teams working together daily to produce the best possible outcomes. Also, build projects around motivated individuals, give people the environment and the support that they need in order to be motivated and trust them to get the job done. This is a very different mindset than a command and control mindset, where some people in the organization may be acting more as task managers. And then lastly, emphasis on face to face conversation give people the ability to have face to face communication and conversation and encourage them to do so. One of the constructs of some of the Agile methods that allows for this, for example, is the daily standup meeting. By having a daily meeting, where people come together, we're having a lot of verbal communication and face to face communication versus relying only on e-mail. 

Some of the development-focused principles are: working software shows progress. Again, the work...the primary measure of progress in Agile is working software versus documentation or any other measure. Also, sustainable development pace, it's important to maintain a development pace that's sustainable for the team and that doesn't burn people out. Lastly on this slide, requires technical excellence and good design, so Agile methods also wanted to emphasize that it's important to have technical excellence and good design in order to achieve a high quality, high-level product. The remaining principles in the Agile Manifesto are simplicity and that means simplicity and design, and implementation, and communication and processes. Self-organizing teams, where people are given the autonomy to figure certain things out like who is working on what tasks. And then finally, regular team retrospectives and adaptation, when you give people an opportunity to retrospect and adapt their processes on a regular basis, you start to see improvements and processes and improvements and motivation and the way that people work together. 
The Whole Team Approach 
In this video, we'll be talking about "the whole team approach", which is a software development approach that was initially presented by extreme programming. The whole team approach is a collaborative approach to software development that emphasizes the participation of the whole team including business people, designers, developers, testers, et cetera in developing the software that we're producing. The whole team approach focuses on having smaller teams that typically don't exceed seven members. The teams between five and nine members were able to have more effective communications than teams that grow beyond that number. We also focused on having collocated teams or teams that are all seated in the same location. Having collocated teams removes any barriers between the team members and enables better communication. The benefits of utilizing a whole team approach are having strong working relationships between team members. We see more effective cooperation, collaboration, teamwork, and communication. We also see shared knowledge amongst the team. So instead of one person having all the knowledge around one area of a project, we start to see people sharing their knowledge and more people becoming experts in more areas. And then finally, everyone collectively is responsible for the outcome of a project. 

One aspect of the whole team approach is that everybody is responsible for the quality of the end product. In order to have that responsibility to be shared, we need to have the support of both developers and testers and producing some of the things that allow us to have higher quality products, such as acceptance tests, test strategies, and automated test suite. In order to have effective test suites and acceptance tests, we need to make sure that there is a strong communication and collaboration between developers and testers to produce these in the best way possible. We also encourage having informal meetings where developers and testers might come together to think about the quality of the products and potentially create new product increments based on their discussions. And then finally, collaboration helps us finalize the feature set and ensure that we have achieved the development and the testing required to have quality products that can be produced and then released into production. 
Early and Frequent Feedback 
In this video, we'll be talking about early and frequent feedback and the importance of obtaining early and frequent feedback for agile teams and the mechanisms that allow us to do so. Early and frequent feedback is vital for agile development teams. It's a way for us to ensure that the team is headed in the proper direction at every point along the way in developing or completing a project versus waiting until the end. One of the mechanism or constructs of agile that allows us to obtain early and frequent feedback is the fact that we develop product increments at the end of every sprint. With each product increment, we have an opportunity to get stakeholder's feedback. The product backlog that we have created at the beginning of the project and that evolves throughout the life cycle of a project is the blueprint for our product increments. 

If you recall, we have spoken about Waterfall development and how Waterfall breaks activities into phases, with each phase being distinctly separated from the next. So one of the phases would be design, which then moves us on to development, which then moves us onto testing. On the other hand, agile development breaks activities into small chunks that we complete in every iteration in order to produce that product increments. So feedback is then gathered at the end of each iteration and this is a vital part again of our early and frequent feedback. That feedback is important for adopting modifications or changes needed to the product, and it helps us deliver the highest business value features for our customers and stakeholders. 

The benefits of obtaining early and frequent feedback through the product's increments is that we're able to break down all the requirements so when we create our product backlog, we take the general overall requirements for a project and break them down into smaller chunks and smaller pieces that we can create product increments from. This helps us avoid mistakes when we approach the project as a larger overall project. It also helps us achieve robust product development, where we're building exactly what the customer wants by getting the customer's feedback every step along the way. It also helps us achieve early clarification of customer needs so as the customer is looking through our product increments, testing them, using them, they are able to give us feedback on what's working, what's not working, and what other needs they may have. It also helps reduce misunderstandings of requirements since customers are actually getting their hands on the finalized products increments versus waiting until the end when everything has been integrated. And finally, early and frequent feedback through product increments helps us achieve continuous improvement by continuing to inspect each product increment, adapt, and improve, and also improve the way that we work together to produce those product increments. 
Extreme Programming (XP) 
In this video, we'll be talking about Extreme Programming, or XP, and the main principles and values behind XP. XP is a popular agile methodology that focuses on the ongoing, rapid delivery of small releases of software. XP relies on close collaboration between team members and the continuous refinement of program requirements through that close collaboration. XP focuses on having small programming teams that can design, develop, test, and update code, all within the same team. The core values of Extreme Programming are the following. Communication, there is a strong focus on positive communication within Extreme Programming teams. When XP first came out, it was an attempt at coming out of some of the more corporate ways of managing projects and working together as teams, and they wanted to emphasize a strong positive communication between both stakeholders and team members and the team members themselves. The idea is that with strong collaboration and positive communication, we can get at the best solutions for problems instead of laying blame and pointing fingers. 

The next value is simplicity. And simplicity applies to both the technology and the techniques with which we implement technology. So XP has a strong focus on simple design and simple fulfillment of requirements. One of the next values is feedback. So XP was one of the first methods or frameworks to incorporate continuous feedback through code reviews between the team members, and peer reviews, as well as stakeholder reviews and demos. And then finally, courage. So in XP, the value of courage was brought up as a value that the team members should care about, and it's an important one. We want to have the courage to discard old code when we have better code that we could write or when we have a better or a simpler way of approaching our requirement. This value helps us let go of certain ideas around possessiveness of code, and it actually opens up the code to be more collaborative amongst team members. 

The primary principles of XP are collective ownership. So in XP, all developers are responsible for the full body of code including code that they didn't personally work on. So if a developer was in the code base and could see some code that needed fixing, their responsibility is to go in and fix it even if that code wasn't theirs or they didn't write it. Collective ownership encourages collaboration and open communication between team members and helps us elevate the quality of our code. Next is continuous integration. In continuous integration, code is integrated and tested into the full code base on a regular basis. So the entire system is built and tested at least once a day. Next is energized work. One of the primary principles of XP is that overworked and fatigued team members are more prone to making mistakes, and so we want to create a sustainable pace for team members so that they are constantly energized, more alert, and more productive. This reduces the number of bugs and issues in our code. Also having a shared workspace, so teams that are collocated and work together in the same workspace have an opportunity for instant feedback between each other as well as improved communication, and they get a boost of productivity. 

And then finally, on-site customer, and what this principle means is that by having access to someone who is either the customer or the customer representative directly on on-site, we can develop our software faster, and we have instant access to that person who is actually defining the requirements that the software must meet. They are going to be there and available to answer questions immediately versus having long turnaround times. 
Scrum 
In this video, we'll be talking about the Scrum Agile framework and about the main concepts behind this framework. Scrum is an Agile framework that allows us to do software product development with quick iteration cycles. The focus in Scrum is on producing working product increment after every iteration, which goes back to one of the Agile values and principles where software and working software are the primary measure of progress. Scrum is based on an iterative approach to the software development cycle. So what these means is that projects are broken up into development units called sprints. A sprint is a time-boxed iteration of the complete software development cycle. In other words, we do all of the activities involved in a software development cycle and each of those iterations are sprints. So in sprints...and in each sprint, we're doing planning and analysis, design and development, testing, and then delivery of the product increment to the customer. The difference between Scrum and, for example, Waterfall is that in Scrum many of these activities are happening synchronously, so team members are collaborating and working together to do testing alongside development and planning alongside the testing et cetera versus waiting for each phase to complete before moving on to the next phase. 

With product increments, we're attempting to deliver potentially shippable software. What this means is that each product increment contains the highest priority functionality and it should be gone through the whole development cycle, where we have developed it, there has been development testing, there has been testing from the QA team et cetera. Product increments then grow in functionality with each completed sprint, so we may start with a minimal implementation of a feature or functionality that then grows more robust as we go on to the next sprints. 

There are number of core roles within Scrum. Those three core roles are the product owner, the team, and the Scrum master. The product owner is really responsible for the product's backlog, creating it, maintaining it, prioritizing it, and decisions regarding what is important and not important for the team to focus on. The product owner also accepts or rejects each product increment that the team delivers. The team is responsible for figuring out how to produce what the product owner needs; how to collaborate who does what and be a self-organizing team that autonomously reaches and fulfills their commitment to the product owner. The Scrum master is the keeper of the process and will stay on top of the process and work with the team to make sure that the right meetings are happening, the right conversations are happening, and the things don't get derailed unnecessarily by others. 
Kanban 
In this video, we'll be talking about Kanban as an Agile approach for software development. One of the main characteristics of Kanban is its flexibility, where Kanban mainly focuses on achieving flow for a team by limiting work in progress and redefine work in progress as any active tasks that are currently being worked on. By limiting the number of tasks that anybody or a team can work on at any given time, we see that teams will collaborate to move things from "In Progress" to "Done" and allows the team to achieve a state of flow, where things are moving and getting done before picking up new work. In Kanban, the product owner can reprioritize work, where changes outside the current work items don't really impact the team. One of the most important things is that the product owner ensures that the most important work remains on the top of the backlog. That way the team is always share that they are working on the maximum value items and delivering those back to the business. In this scenario, we find that there is no need for iterations of fixed length as long as the team is achieving a state of flow and working through and getting things done based on the highest priority. 

One of the main things to calculate or to track in Kanban is cycle time. Cycle time is a key metric that calculates the amount of time for any unit of work to cycle through the team's workflow. By understanding our team cycle time, we're able to forecast the delivery of future work. In order to ensure smaller cycle times, we overlap skill sets on our team, so we have different people that are able to do many different things versus having a single person that holds on to a specific skill sets. Having single people be responsible for a single type of work can create bottlenecks in a team that's trying to do a Kanban or implement a Kanban framework. Having overlapping skill sets also allows us to spread knowledge through code review and mentoring. And those two activities can help us spread knowledge and ensure that we have a cross-functional team. 

One of the great things about Kanban is that it helps us achieve efficiency. By limiting work in progress, we avoid multitasking, which always negatively impacts efficiency. The key to limiting work in progress is that, work in progress limits help us reveal bottlenecks. If things are getting stuck In Progress, for example, we're able to see why things aren't moving into Done or we can start investigating why things gets stuck in that state. We're also able to see the causes of why things get stuck. For example, is there a lack of focus, is it a people issue, is it a skill set issue that we need to enhance on our team? 

One other key principle in Kanban is continuous improvements, which is a shared principle across all other Agile frameworks as well. By having a visual representation of our workflow, which is very typical with teams that are implementing Kanban, we're able to identify bottlenecks and visually, quickly see what the status is of our work items and items that are In Progress. Some of the charts that we might use in Kanban are called Control charts that help us see the cycle time for each issue or each item that's going through our workflow. Another chart that we might use is cumulative flow diagrams, which show the number of issues in each state of our workflow. 
Collaborative User Stories 
In this video, we'll be talking about the concept of user stories and how they are used and created collaboratively in Agile projects to capture requirements and develop products. Although, they are not the only way to capture requirements, user stories have become very popular in Agile projects and within Agile teams. There are number of features and characteristics that user stories have that made them this popular including, user stories are the primary artifacts of development, these means that user stories contain enough information to ensure that the development team knows how to fulfill the requirements. And if not, it contains enough information to provide a point of conversation. User stories should also express a discrete functionality that a system must provide. User stories are used throughout the development process from capturing the initial requirement to including details that come out of conversations with the product's owner and the team to the acceptance criteria necessary to validate that the story fulfills the customer's requirements. User stories are also realistic and easy for both the team members and customers to understand and they are written in such a way that they can be translated easily into a business requirement as well as a technical requirement. Also, user stories must be estimable so developers must be able to look at a user story, read it, and understand enough to be able to estimate how long they'll take to implement it. 

The components of user stories are a user story is a written description of a required functionality. And what these means is that the customer or the customer representative, so the product's owner, will produce a written description of something that a system must do or that a user must be able to do with our system. User stories also contain conversations about the stories. So when conversations occur between the customer or the customer representative and developers, throughout the release and iteration planning cycles, developers and the product's owner will note those conversations and the results of those conversations in the user stories. User stories also contain testing requirements or acceptance criteria, which allow the test team to create their test cases. So by testing these acceptance criteria, we're able to verify that the customer's needs are being met. 

The process of using user stories through planned a development projects can be broken into five main steps as we're going to show in the next few slides. However, sometimes the order of these steps isn't as important as you see or it's not important to follow the same order that you see in these slides. So obviously, one of the first steps is to write the user stories. Sometimes, we select an iteration length next or we might select an iteration length with our team that we have stayed consistent with for a long time and that's just the iteration length that we'll use regardless of the user stories that we have just written. Step 3 is to estimate the work. So once we look at the user stories, we understand them, we have the right conversations, we're able to then as a team estimate the amount of work required in order to get it done. Usually, again, in Agile projects, we're estimating by relative estimation, so we're looking at the size and complexity of a story as compared to others. In Step 4, we're prioritizing and allocating stories to either a sprint or a release. And in Step 5, we're updating estimates and iterations and this is something that happens at the end of each sprint and sometimes during a sprint as part of our backlog grooming process or at the end of a release. 
Creation of User Stories 
In this video, we're going to be talking about creating user stories and what to take into consideration when creating good user stories. We've talked about the process of creating collaborative user stories and the importance that user stories have in the development process for software projects. In this video, we'll be focusing more on what things to take into consideration in order to ensure that our user stories are good user stories. In order to do so, we have a criteria called invest. Invest stands for independent, negotiable, valuable, estimable, small, and testable. And in the next slides, we'll be going through each one of these. So good user stories are independent, which means the stories can be worked on in any order, and this allows for true prioritization. Technically speaking, sometimes we do have to order certain stories that come before others, but for the most part, we want to reduce any dependencies in between stories. 

Next is negotiable. When we talk about negotiable user stories, we want to be able to have the opportunity to negotiate some of the terms of user stories with the customer or even with other developers and the testers. What this means is that user stories should come as a functional requirement or a need that the user has and not a specific way of implementing that need. This gives the developers and the team the freedom to look into different ways of implementing the requirement and fulfilling the need. Next is valuable. User stories must deliver value to the end user, and this is one of the main criteria of good user stories. The value is seen as a project-related value. And with the focus of agile frameworks on delivering higher business value first, then we understand the importance of this criteria for user stories. Next is estimable. If a user story is too vague, or not specific enough, or too large, it's very hard for team members to estimate the effort required in implementing it. Therefore, one of the important criteria for good user stories is that they are clear enough and of a size that a team member can quickly identify the relative complexity of that user story. 
Heading: Creation of User Stories.

User stories must be estimable to properly prioritize stories based on the effort required to work on it. 

Talking about size, one of the criteria of good user stories is that they are small. No user stories should require more than a sprint to work on, and we prefer that user stories are actually small enough to complete within one to two days. By keeping user stories small, we're able to ensure that the user stories we've selected can be developed, and implemented, and tested within the course of a sprint. And finally, testable. In order to have good user stories, they must be testable, and that requires that we have good acceptance criteria included in the user story. User stories must be tested fully in order for us to deliver the complete product. So this is one other very important criteria for good user stories. 
Retrospectives 
In this video, we'll be talking about retrospectives and how they are used by agile teams as an opportunity to improve. Agile retrospectives are a powerful tool when used by agile teams. They are special meetings that take place at the end of a specific period of work, usually at the end of a sprint, or iteration, or at the end of a release. When they come at the end of a sprint, they usually come on the last day of a sprint. Agile retrospectives should be team-driven, meaning they are focused on issues and things that the team wants to discuss together. And they are driven by the members of the team versus having somebody be in control of the meeting. A facilitator is usually required just in order to make sure that the discussions are happening, and everybody has an opportunity to contribute. The purpose of agile retrospectives is to provide an opportunity for us to inspect and then adapt our processes. If there are certain processes that we've been implementing that haven't been effective, this is our chance to take a look at those and see how we can improve them. It also gives us an opportunity to analyze our results. Are we delivering the quality that we expect to be delivering within our sprints? Are we delivering at the velocity that we were expecting to be delivering? And then finally, we're able to identify ways to improve after we've looked at our results and looked at our processes. 

Some of the things that we may try to improve as a result of looking and then inspecting our processes within retrospectives are our effectiveness as a team. Are we building the right things? Are we delivering according to our customers' expectations and are we fulfilling their needs? Productivity is another one. Are we as productive as we would like to be? Are we, for example, wasting time on certain processes or other things that we could be instead spending time doing work? Are we overbooking and trying to do too much within a sprint? We also might try to improve the quality of our output, either additional exercises or things that we can be implementing within a sprint in order to ensure that our quality is higher. And finally, satisfaction. Are we satisfied as a team with the environment, with our dynamic? Are our customers satisfied with our work products? We also have an opportunity in our retrospective to review the project status. However, we're going a little bit further than where we went when we were in our review meeting or our demo. In the demo or the review meeting, we look at which stories were completed and which stories weren't completed. And in the retrospective, we can start to look at root causes and why or why not certain stories were completed. 

Some of the considerations when planning and implementing agile retrospectives are...to the extent possible, retrospectives should be unique. It's easy to get into a rut and continue to talk about what went well, what didn't go well, and how can we improve. A good facilitator will research different ways to facilitate this meeting and make them unique, and exciting, and interesting. Keep the focus in retrospectives on the current activity. So we will keep the focus on the current sprint versus looking too far into the past or looking too far into the future. Having a retrospective without gathering data upfront is not very useful because data will help the team sort through issues where we can look at root causes and look at things that may have caused some of the results that we're seeing. Also, we try to encourage as much participation as possible by selecting activities that promote team brainstorming, team learning, and team decision making. 

Some other considerations are that retrospectives should not be used for individual performance feedback. We're looking at our performance together as a team. While analyzing processes, we're looking at things that went well; we're looking at things that need to be improved at a team level. Individual performance should be handled by managers directly with their reports. Also talking about our issues in retrospectives is not a solution for inadequate skills on the team. If we have issues with technical skills or issues collaborating together, those go beyond the scope of a retrospective and should be handled elsewhere. And then finally, retrospectives are not used to correct the organizational approach to building software. If an organization has a certain mental model of how software is developed or how teams must work together, retrospectives aren't the right place to fix that. Again, retrospectives are a very powerful tool that agile teams can use in order to improve, inspect, and adapt. 
Continuous Integration 
In this video, we'll be talking about continuous integration as a practice in Agile projects, how continuous integration provides a baseline for testing, and some of the challenges and benefits. Continuous integration is the practice of merging all developers working copies of code into a mainline branch. Then we build that merged code at least once a day. The objectives of continuous integration are to minimize the efforts and overall duration required for each integration. So by integrating multiple times, then integration stop becoming such a big production and we have less issues to deal with when we do integrate, or handling the issues becomes a lot easier because the change from the last integration to the next one is a smaller change than when we have a large integrations. Also, one of the objectives is to deliver product versions that are suitable for release, but also that are suitable for testing on an integration testing level. 

Continuous integration involves the effective use of Continuous integration servers, which allow us to configure certain times of day when we integrate code, version control tools, which ensure that our code base is version controlled, build tools, unit testing frameworks, and other tools. So for example, one of the tools used a lot in continuous integration is Concurrent Versions System, or CVS, some other tools are Ant, MSBuild, JUnit, and others. 

Some of the considerations when doing continuous integration are that continuous integration as we have mentioned does rely on having multiple tools integrated and working well together for testing, automation, and version control. Ensuring that those tools work well together takes time and also some cycles from the development team, but it ultimately pays off in the end. There also may be scheduling challenges if people are merging in code at the same time or trying to merge in code at the same time that affects each other's code. It may also seem expensive to do continuous integration with all of the tools and time required. However, the payoff in the end is a lot larger than the cost. 

Some of the benefits of continuous integration are that we're able to detect defects early. It also helps us simplify the debugging process because the difference between the last version of the code and the current version is a small difference. It also helps us minimize the integration phase when we're integrating code. It provides immediate feedback to developers. And it raises visibility of a project by making it clearly visible whether the build has worked or whether it has failed. 
Release and Iteration Planning 
In this video, we'll be talking about release and iteration planning as activities in Agile projects, and we'll highlight the involvement of testers in these activities. Release planning is a process that helps teams to find their strategy for implementing a project. When we do release planning, we set a release goal and a timeframe for the release and then we start thinking about how to split up the work into different iterations. In the release planning meeting, we're talking at a high level of the functionality required by the system and some of the user stories that will fulfill the requirements of the system. Testers must be involved in the release planning activity since testers help develop user stories. They help seek further clarification on user stories by highlighting where there is insufficient information, and they provide some high-level test planning as well as they highlight some testing risks. Testers have a unique perspective when looking at user stories because they are able to see where the areas that need to be tested are and they are able to see what questions the user stories aren't really answering for purposes of testing. 

Iteration planning is an activity that's performed after release planning and it takes some of the user stories and some of the work that's been designated for the next iteration and helps define independent tasks so the team works together to split up the user stories into independent tasks including testing tasks. During iteration planning, we can do a risk assessment of certain stories, which involves also the testers from a risk perspective. The tester involvement in iteration planning is to help create acceptance tests for the user stories and to estimate their testing tasks. Iteration planning and release planning are two great opportunities for testers to become involved in the planning process for Agile projects and provide their unique perspective on what clarification is needed in order for testing to go well. 
Heading: Release and Iteration Planning.

A graphic that displays information about Iteration planning contains a flow chart with the following steps: Determine target velocity, Adjust priorities, Identify iteration goal, Select user stories, Split user stories into tasks, and Eliminate tasks.

The steps Determine target velocity and Adjust priorities are grouped together under the following heading: Do in any sequence. 